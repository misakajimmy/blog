---
title: "Lumino 的性能与优化：与 React 的对比思考"
weight: 9
---

> 前面几篇更多在讲架构和机制，这篇换个角度，把问题缩成一句话：  
> **Lumino 这种“Widget + virtualdom + 布局系统”的组合，在性能上大概处于什么水平，它的瓶颈在哪儿，以及和 React 相比，我们在优化时应该注意什么。**

## 先说定位：Lumino 关心的“性能问题”跟普通业务前端不太一样

先别急着把 Lumino 和“做后台管理界面”的 React App 放一起比。  
Lumino 设计时主要盯的是这几类压力场景：

- **IDE / 开发工具**：长时间运行、窗口/面板频繁打开关闭、拖拽分屏、Tab 切换。  
- **数据工具（如 JupyterLab）**：同时存在大量 Widget（输出面板、Notebook 单元格、数据表格等），需要在有限屏幕下做虚拟化和布局计算。  

所以它更在意：

- **布局计算和重绘频率**：频繁拖拽、分屏、缩放时，不能把浏览器卡死。  
- **大量 Widget 并存时的管理成本**：每个 Widget 都有生命周期和消息循环，调度如果粗糙很容易爆栈/卡顿。  
- **长时间运行时的内存稳定性**：不希望 IDE 打开一天之后越来越卡。

而 React 更常被用在：

- 复杂但以“表单 + 列表 + 图表”为主的业务 UI；  
- 更强调「声明式 + 可组合」的开发体验，性能问题多集中在 diff 频率、组件粒度、状态切片等方面。

这两个世界有重叠，但焦点不完全一样。

## Lumino 层面的性能基石：三块砖

粗略看，Lumino 在性能上主要依赖三块基石：

1. **轻量的 virtualdom**  
   - 不搞复杂的 hook/state 体系，就是一个“描述虚拟树 + 打补丁”的库；  
   - 这使得它在内部组件（菜单、命令面板等）的 DOM 更新上成本比较可控。

2. **消息驱动的 Widget 生命周期（messaging）**  
   - 用 `MessageLoop` 把 `onUpdateRequest` / `onResize` 这些钩子调度起来，避免直接递归和多余调用；  
   - 可以在必要时把多个更新合并到一轮消息循环中。

3. **布局组件的增量更新**  
   - DockPanel / SplitPanel / TabBar 等布局变化时，只动受影响的子树；  
   - 内置一些合理的限制（比如拖拽区域的命中计算、布局树的结构）来避免退化成“全局重排”。

这些东西加在一起，可以撑起 JupyterLab / Theia 这种规模的应用在普通开发机上长期运行。

## 和 React 的几个典型对比点

### 1. 更新触发的心智模型

- **React**：  
  - `setState` / hook 改变状态 → 触发一次“从根/某个子树开始的重新渲染” → React 内部做 diff + commit；  
  - 强调“你只描述最终状态，我来算中间过程”。

- **Lumino**：  
  - 大部分时候是“你显式调用 `widget.update()`”，然后在 `onUpdateRequest` 里决定怎么渲染（用 virtualdom 或直接 DOM）；  
  - 更强调“由你来控制何时重绘，我帮你调度生命周期”和“给你一个 VDOM 工具加速 patch”。

结果是：

- React 更适合大面积声明式 UI，性能优化偏向“减小渲染树 / 拆状态 / memo”。  
- Lumino 更适合精细控制少量但复杂的 Widget，性能优化偏向“控制 update 频率 / 减少不必要的消息派发 / 控制布局复杂度”。

### 2. diff 粒度与重绘策略

- **React**：  
  - 通常从某个组件子树根开始 diff；  
  - 有 `React.memo`、`shouldComponentUpdate`、hook 依赖数组等机制帮你减少不必要的 diff。

- **Lumino virtualdom**：  
  - 你自己决定在 `_render()` 里构造多大的一棵 VNode 树，然后交给 `VirtualDOM.render`；  
  - 没有组件级别的“自动跳过”，需要你从 Widget 设计上就把“更新频繁的小块”和“很少变的大块”拆开。

这意味着：

- 在 Lumino 里，**不要让一个 Widget 的 `_render()` 管太多内容**，否则每次 `update()` 都会 diff 一大块；  
- 对比 React 的“拆组件”，这里更像是“拆 Widget 或拆局部视图”。

### 3. 布局和重排成本

- React 本身不负责布局，只是更新 DOM，布局/reflow 由 CSS 决定；  
- Lumino 的 DockPanel / SplitPanel 自己参与了布局决策（位置、尺寸计算），  
  - 优点：IDE 类需求实现起来更可控；  
  - 风险：布局树如果太复杂、嵌套太深，频繁拖拽/resize 时的计算成本会抬高。

这里更接近“游戏 UI / 自己写布局引擎”的思路，而不是纯 CSS 布局。  
在复杂 IDE 场景里，这反而是优势：可以精确控制哪些区域需要重算，哪些可以保持不动。

## 在 Lumino 里常见的几个性能坑 & 优化思路

结合前面讲过的模块，我自己会注意这些点：

### 1. 不要滥用 `update()`，尤其是“级联 update”

典型坑：

- A Widget 的 `onUpdateRequest` 里调用 B 的 `update()`，B 的 `onUpdateRequest` 又调用 C 的 `update()`……  
- 如果缺乏节制，很容易在一次状态变化里触发多层 Widget 的级联重绘。

优化思路：

- 做好“状态层”和“视图层”的拆分，用 signaling 把模型变化广播出去，让每个 Widget 自己决定何时 `update()`；  
- 能批量更新的地方，尽量合并到一次 `update()` 调用里，而不是在一个事件回调里多次触发。

### 2. 大量 Widget 并存时，注意生命周期清理

长时间运行的 IDE 容易出现的不是“单次卡顿”，而是：

- 某些 Widget 虽然从布局里移除了，但没有被 `dispose()`；  
- 或者 `onBeforeDetach` 里没有清掉事件监听 / signal 订阅；  
- 导致消息循环还在偷偷调度它们，内存占用和 CPU 占用慢慢累积。

这里和 React 很像：  
**React 要在 `useEffect` 里写好 cleanup，Lumino 要在 `onBeforeDetach` / `dispose()` 里配合 disposable 把尾巴收干净。**

### 3. 布局树的复杂度控制

在 DockPanel 里，如果你疯狂拆分区域、嵌套 Panel，理论上布局计算会变重。  
常见的工程级策略：

- 设计时限制最大分屏层级（比如不要嵌套太多层 split）；  
- 对某些“辅助视图”采用 overlay/抽屉之类的轻量展示方式，而不是都塞进 DockPanel 树里；
- 对布局做序列化/还原时，也可以顺便做一些“瘦身”（比如合并已经空掉的区域）。

React 这边类似的问题是“大而全的组件树 + 过多 context/hook”，  
但解决手段不同：React 偏向拆组件和状态切片，Lumino 偏向合理剪裁布局树和 Widget 粒度。

## 当你在 Theia 上做二次开发时，可以关注的性能点

站在 Theia 使用者的角度，很多底层优化已经由 Lumino 负责了，我们更需要关注的是：

- **自己的扩展/视图里：**
  - 避免在高频事件（如 `mousemove`、`scroll`）里频繁 `update()`；  
  - 用合理的 debouce/throttle 包一下，或者只在状态真正变化时更新；  
  - 注意 `dispose()` / `onBeforeDetach` 把事件监听和 signal 断干净。

- **和 React 结合时：**
  - React 组件本身继续遵守常规优化套路（比如 `memo`、避免在 render 里创建新函数等）；  
  - 注意 React 的更新不要频繁触发 Lumino 布局/尺寸变更，必要时可以把某些区域固定尺寸，减少 reflow。

总体感觉是：  
**Lumino 提供的是一套偏“工程型工具”的基础设施，默认性能足够支撑 IDE 等重度场景；  
真正更容易踩坑的地方，往往是在我们的扩展/业务视图里对 update/布局/资源释放的粗心使用。**

## 小结：别指望它像 React 一样“自动聪明”，但它给了你足够的控制力

最后收个口：

- 和 React 相比，Lumino 在“性能自动优化”的花活上要朴素很多——没有 hook 依赖分析、没有调度优先级、没有 concurrent 模式。  
- 但它给了你另一种东西：**对生命周期和布局非常直接的控制权**，再配上一套轻量 virtualdom 和消息循环，让你能在 IDE 这类复杂场景里按需、精确地优化。

从我的学习体验来说，  
**把 Lumino 当成“低层基础设施 + 需要你自己有性能意识的工具箱”，再用 React/Vue 承载那些更偏业务的视图，是一个相对舒服的分工方式。**

